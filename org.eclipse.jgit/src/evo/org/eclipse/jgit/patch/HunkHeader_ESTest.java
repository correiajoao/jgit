/*
* This file was automatically generated by EvoSuite
* Tue Feb 25 16:57:48 GMT 2020
*/

package org.eclipse.jgit.patch;

import org.eclipse.jgit.diff.Edit;
import org.eclipse.jgit.diff.EditList;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.OutputStream;

import static org.evosuite.runtime.EvoAssertions.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.junit.Assert.*;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true)
public class HunkHeader_ESTest extends HunkHeader_ESTest_scaffolding {

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se os
    *     valores iniciais do HunkHead são iguais aos esperados.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test00() throws Throwable {
        byte[] byteArray0 = new byte[0];
        FileHeader fileHeader0 = new FileHeader(byteArray0, 37);
        EditList editList0 = new EditList();
        HunkHeader hunkHeader0 = new HunkHeader(fileHeader0, editList0);
        String[] stringArray0 = new String[7];
        stringArray0[1] = "/dev/null";
        int[] intArray0 = new int[2];
        hunkHeader0.skipLine(stringArray0, intArray0, 1);
        assertEquals(0, hunkHeader0.getNewLineCount());
        assertEquals(0, hunkHeader0.getNewStartLine());
        assertEquals(0, hunkHeader0.getLinesContext());
        assertArrayEquals(new int[]{0, 9}, intArray0);
        assertEquals(0, hunkHeader0.getEndOffset());
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     a função skipLine() lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test01() throws Throwable {
        byte[] byteArray0 = new byte[0];
        FileHeader fileHeader0 = new FileHeader(byteArray0, 37);
        EditList editList0 = new EditList();
        HunkHeader hunkHeader0 = new HunkHeader(fileHeader0, editList0);
        String[] stringArray0 = new String[7];
        int[] intArray0 = new int[2];
        // Undeclared exception!
        try {
            hunkHeader0.skipLine(stringArray0, intArray0, 1);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("org.eclipse.jgit.patch.HunkHeader", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste não verifica o comportamento da classe alvo.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test02() throws Throwable {
        byte[] byteArray0 = new byte[2];
        FileHeader fileHeader0 = new FileHeader(byteArray0, 0);
        HunkHeader.OldImage hunkHeader_OldImage0 = mock(HunkHeader.OldImage.class, new ViolatedAssumptionAnswer());
        HunkHeader hunkHeader0 = new HunkHeader(fileHeader0, (byte) (-1), hunkHeader_OldImage0);
        StringBuilder stringBuilder0 = new StringBuilder(0);
        String[] stringArray0 = new String[7];
        stringArray0[0] = "/dev/null";
        int[] intArray0 = new int[2];
        hunkHeader0.copyLine(stringBuilder0, stringArray0, intArray0, 0);
        assertEquals("/dev/null", stringBuilder0.toString());
        assertArrayEquals(new int[]{9, 0}, intArray0);
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     a função copyLine() lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test03() throws Throwable {
        byte[] byteArray0 = new byte[2];
        FileHeader fileHeader0 = new FileHeader(byteArray0, (byte) 0);
        HunkHeader hunkHeader0 = fileHeader0.newHunkHeader(2);
        String[] stringArray0 = new String[7];
        int[] intArray0 = new int[2];
        // Undeclared exception!
        try {
            hunkHeader0.copyLine((StringBuilder) null, stringArray0, intArray0, 1);
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("org.eclipse.jgit.patch.HunkHeader", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     o valor da variável startoOfset setado é igual ao retornado por getStartOffset().
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test04() throws Throwable {
        byte[] byteArray0 = new byte[6];
        FileHeader fileHeader0 = new FileHeader(byteArray0, 92);
        HunkHeader hunkHeader0 = new HunkHeader(fileHeader0, 633);
        StringBuilder stringBuilder0 = new StringBuilder(0);
        hunkHeader0.newStartLine = (int) (byte) (-90);
        String[] stringArray0 = new String[2];
        int[] intArray0 = new int[1];
        hunkHeader0.extractFileLines(stringBuilder0, stringArray0, intArray0);
        assertEquals(633, hunkHeader0.getStartOffset());
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     o valor da variável startOffset setado é igual ao retornado por getStartOffset().
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test05() throws Throwable {
        byte[] byteArray0 = new byte[5];
        FileHeader fileHeader0 = new FileHeader(byteArray0, (byte) (-17));
        HunkHeader hunkHeader0 = fileHeader0.newHunkHeader((byte) 69);
        hunkHeader0.newLineCount = (-2);
        StringBuilder stringBuilder0 = new StringBuilder("/dev/null");
        String[] stringArray0 = new String[2];
        int[] intArray0 = new int[0];
        hunkHeader0.extractFileLines(stringBuilder0, stringArray0, intArray0);
        assertEquals(69, hunkHeader0.getStartOffset());
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     o valor da variável endOffset é igual ao retornado por getStartOffset().
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test06() throws Throwable {
        byte[] byteArray0 = new byte[2];
        FileHeader fileHeader0 = new FileHeader(byteArray0, 1175);
        HunkHeader.OldImage hunkHeader_OldImage0 = mock(HunkHeader.OldImage.class, new ViolatedAssumptionAnswer());
        HunkHeader hunkHeader0 = new HunkHeader(fileHeader0, 0, hunkHeader_OldImage0);
        hunkHeader0.nContext = (-306);
        int[] intArray0 = new int[7];
        hunkHeader0.extractFileLines((StringBuilder) null, (String[]) null, intArray0);
        assertEquals(0, hunkHeader0.getStartOffset());
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se os
    *     valores iniciais do HunkHead são iguais aos esperados.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test07() throws Throwable {
        byte[] byteArray0 = new byte[4];
        FileHeader fileHeader0 = new FileHeader(byteArray0, (byte) 0);
        EditList editList0 = new EditList();
        HunkHeader hunkHeader0 = new HunkHeader(fileHeader0, editList0);
        hunkHeader0.extractFileLines((OutputStream[]) null);
        assertEquals(0, hunkHeader0.getLinesContext());
        assertEquals(0, hunkHeader0.getNewStartLine());
        assertEquals(0, hunkHeader0.getNewLineCount());
        assertEquals(4, hunkHeader0.getEndOffset());
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste possui duplicações em relação ao 0, 4, 5, 6.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test08() throws Throwable {
        byte[] byteArray0 = new byte[1];
        FileHeader fileHeader0 = new FileHeader(byteArray0, 44);
        HunkHeader hunkHeader0 = new HunkHeader(fileHeader0, (byte) 69);
        Patch patch0 = new Patch();
        int int0 = hunkHeader0.parseBody(patch0, (byte) 69);
        assertEquals(69, hunkHeader0.getStartOffset());
        assertEquals(69, int0);
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste possui duplicações em relação ao 0, 4, 5, 6, 8.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test09() throws Throwable {
        byte[] byteArray0 = new byte[2];
        FileHeader fileHeader0 = new FileHeader(byteArray0, 3);
        HunkHeader hunkHeader0 = new HunkHeader(fileHeader0, (byte) 32);
        hunkHeader0.newLineCount = 1312;
        EditList editList0 = hunkHeader0.toEditList();
        assertEquals(32, hunkHeader0.getStartOffset());
        assertNotNull(editList0);
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste possui duplicações em relação ao 0, 4, 5, 6, 8.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test10() throws Throwable {
        byte[] byteArray0 = new byte[2];
        FileHeader fileHeader0 = new FileHeader(byteArray0, 1175);
        HunkHeader.OldImage hunkHeader_OldImage0 = mock(HunkHeader.OldImage.class, new ViolatedAssumptionAnswer());
        HunkHeader hunkHeader0 = new HunkHeader(fileHeader0, 0, hunkHeader_OldImage0);
        hunkHeader0.nContext = (-306);
        EditList editList0 = hunkHeader0.toEditList();
        assertEquals(0, hunkHeader0.getStartOffset());
        assertNotNull(editList0);
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se os
    *     valores inicializados do HunkHead são iguais aos recuperados.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test11() throws Throwable {
        byte[] byteArray0 = new byte[6];
        FileHeader fileHeader0 = new FileHeader(byteArray0, 28);
        Edit edit0 = new Edit(710, 1, 1472, (-277));
        EditList editList0 = EditList.singleton(edit0);
        editList0.add(edit0);
        HunkHeader hunkHeader0 = new HunkHeader(fileHeader0, editList0);
        assertEquals((-1749), hunkHeader0.getNewLineCount());
        assertEquals(0, hunkHeader0.getLinesContext());
        assertEquals(6, hunkHeader0.getEndOffset());
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste possui duplicações em relação ao 0, 4, 5, 6, 8, 10.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test12() throws Throwable {
        byte[] byteArray0 = new byte[2];
        FileHeader fileHeader0 = new FileHeader(byteArray0, (byte) 0);
        HunkHeader hunkHeader0 = fileHeader0.newHunkHeader(2);
        HunkHeader.OldImage hunkHeader_OldImage0 = hunkHeader0.getOldImage();
        hunkHeader_OldImage0.nAdded = 4374;
        int int0 = hunkHeader_OldImage0.getLinesAdded();
        assertEquals(4374, int0);
        assertEquals(2, hunkHeader0.getStartOffset());
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste possui duplicações em relação ao 0, 4, 5, 6, 8, 10, 12.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test13() throws Throwable {
        byte[] byteArray0 = new byte[7];
        FileHeader fileHeader0 = new FileHeader(byteArray0, (-2949));
        HunkHeader hunkHeader0 = fileHeader0.newHunkHeader(1182);
        HunkHeader.OldImage hunkHeader_OldImage0 = hunkHeader0.getOldImage();
        hunkHeader_OldImage0.startLine = (-5);
        int int0 = hunkHeader_OldImage0.getLinesDeleted();
        assertEquals(1182, hunkHeader0.getStartOffset());
        assertEquals(0, int0);
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste possui duplicações em relação ao 0, 4, 5, 6, 8, 10, 12, 13.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test14() throws Throwable {
        byte[] byteArray0 = new byte[2];
        FileHeader fileHeader0 = new FileHeader(byteArray0, (byte) 0);
        HunkHeader hunkHeader0 = fileHeader0.newHunkHeader(2);
        HunkHeader.OldImage hunkHeader_OldImage0 = hunkHeader0.getOldImage();
        hunkHeader_OldImage0.lineCount = (-1);
        int int0 = hunkHeader_OldImage0.getLinesDeleted();
        assertEquals(0, int0);
        assertEquals(2, hunkHeader0.getStartOffset());
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste possui duplicações em relação ao 0, 4, 5, 6, 8, 10, 12, 13.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test15() throws Throwable {
        byte[] byteArray0 = new byte[2];
        FileHeader fileHeader0 = new FileHeader(byteArray0, (byte) 0);
        HunkHeader hunkHeader0 = fileHeader0.newHunkHeader(2);
        HunkHeader.OldImage hunkHeader_OldImage0 = hunkHeader0.getOldImage();
        hunkHeader_OldImage0.nAdded = (-3883);
        int int0 = hunkHeader_OldImage0.getLinesDeleted();
        assertEquals(0, int0);
        assertEquals(2, hunkHeader0.getStartOffset());
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se os
    *     valores do HunkHead são iguais aos recuperados.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test16() throws Throwable {
        byte[] byteArray0 = new byte[17];
        byteArray0[5] = (byte) 32;
        FileHeader fileHeader0 = new FileHeader(byteArray0, 3255);
        HunkHeader hunkHeader0 = fileHeader0.newHunkHeader((byte) 0);
        hunkHeader0.parseHeader();
        hunkHeader0.toString();
        assertEquals(1, hunkHeader0.getNewLineCount());
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se os
    *     valores inicializados do HunkHead são iguais aos recuperados.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test17() throws Throwable {
        byte[] byteArray0 = new byte[4];
        FileHeader fileHeader0 = new FileHeader(byteArray0, (byte) 0);
        EditList editList0 = new EditList();
        Edit edit0 = new Edit(27, 815);
        editList0.add(edit0);
        HunkHeader hunkHeader0 = new HunkHeader(fileHeader0, editList0);
        EditList editList1 = hunkHeader0.toEditList();
        assertEquals(4, hunkHeader0.getEndOffset());
        assertEquals(0, hunkHeader0.getLinesContext());
        assertEquals(0, hunkHeader0.getNewLineCount());
        assertEquals(1, editList1.size());
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste possui duplicações em relação ao 0, 4, 5, 6, 8, 10, 12, 13, ...
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test18() throws Throwable {
        byte[] byteArray0 = new byte[5];
        FileHeader fileHeader0 = new FileHeader(byteArray0, (-1147));
        HunkHeader.OldImage hunkHeader_OldImage0 = mock(HunkHeader.OldImage.class, new ViolatedAssumptionAnswer());
        HunkHeader hunkHeader0 = new HunkHeader(fileHeader0, (byte) 0, hunkHeader_OldImage0);
        int int0 = hunkHeader0.getStartOffset();
        assertEquals(0, int0);
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste possui duplicações em relação ao 0, 4, 5, 6, 8, 10, 12, 13, ...
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test19() throws Throwable {
        FileHeader fileHeader0 = new FileHeader((byte[]) null, 0);
        HunkHeader hunkHeader0 = new HunkHeader(fileHeader0, (-1684));
        int int0 = hunkHeader0.getStartOffset();
        assertEquals((-1684), int0);
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se os
    *     valores inicializados do HunkHead são iguais aos recuperados.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test20() throws Throwable {
        byte[] byteArray0 = new byte[6];
        FileHeader fileHeader0 = new FileHeader(byteArray0, 92);
        HunkHeader hunkHeader0 = new HunkHeader(fileHeader0, 633);
        hunkHeader0.newStartLine = (int) (byte) (-90);
        int int0 = hunkHeader0.getNewStartLine();
        assertEquals((-90), int0);
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se os
    *     valores inicializados do HunkHead são iguais aos recuperados.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test21() throws Throwable {
        byte[] byteArray0 = new byte[17];
        byteArray0[5] = (byte) 32;
        FileHeader fileHeader0 = new FileHeader(byteArray0, 3255);
        HunkHeader hunkHeader0 = fileHeader0.newHunkHeader((byte) 0);
        hunkHeader0.parseHeader();
        int int0 = hunkHeader0.getNewLineCount();
        assertEquals(1, int0);
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se os
    *     valores inicializados do HunkHead são iguais aos recuperados.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test22() throws Throwable {
        byte[] byteArray0 = new byte[4];
        FileHeader fileHeader0 = new FileHeader(byteArray0, (byte) 0);
        EditList editList0 = new EditList();
        Edit edit0 = new Edit((byte) 0, (byte) 92, 815, (byte) 0);
        editList0.add(edit0);
        HunkHeader hunkHeader0 = new HunkHeader(fileHeader0, editList0);
        int int0 = hunkHeader0.getNewLineCount();
        assertEquals((-815), int0);
        assertEquals(4, hunkHeader0.getEndOffset());
        assertEquals(0, hunkHeader0.getLinesContext());
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se os
    *     valores inicializados do HunkHead são iguais aos recuperados.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test23() throws Throwable {
        byte[] byteArray0 = new byte[2];
        FileHeader fileHeader0 = new FileHeader(byteArray0, 1175);
        HunkHeader.OldImage hunkHeader_OldImage0 = mock(HunkHeader.OldImage.class, new ViolatedAssumptionAnswer());
        HunkHeader hunkHeader0 = new HunkHeader(fileHeader0, 0, hunkHeader_OldImage0);
        hunkHeader0.nContext = (-306);
        int int0 = hunkHeader0.getLinesContext();
        assertEquals((-306), int0);
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste possui duplicações em relação ao 0, 4, 5, 6, 8, 10, 12, 13, ...
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test24() throws Throwable {
        HunkHeader.OldImage hunkHeader_OldImage0 = mock(HunkHeader.OldImage.class, new ViolatedAssumptionAnswer());
        HunkHeader hunkHeader0 = new HunkHeader((FileHeader) null, (-1002), hunkHeader_OldImage0);
        hunkHeader0.getFileHeader();
        assertEquals((-1002), hunkHeader0.getStartOffset());
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste possui duplicações em relação ao 0, 4, 5, 6, 8, 10, 12, 13, ...
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test25() throws Throwable {
        byte[] byteArray0 = new byte[5];
        FileHeader fileHeader0 = new FileHeader(byteArray0, (byte) 0);
        HunkHeader.OldImage hunkHeader_OldImage0 = mock(HunkHeader.OldImage.class, new ViolatedAssumptionAnswer());
        HunkHeader hunkHeader0 = new HunkHeader(fileHeader0, (byte) 0, hunkHeader_OldImage0);
        hunkHeader0.getFileHeader();
        assertEquals(0, hunkHeader0.getStartOffset());
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste possui duplicações em relação ao 0, 4, 5, 6, 8, 10, 12, 13, ...
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test26() throws Throwable {
        byte[] byteArray0 = new byte[5];
        FileHeader fileHeader0 = new FileHeader(byteArray0, (byte) (-17));
        HunkHeader hunkHeader0 = fileHeader0.newHunkHeader((byte) 69);
        hunkHeader0.getFileHeader();
        assertEquals(69, hunkHeader0.getStartOffset());
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste possui duplicações em relação ao 0, 4, 5, 6, 8, 10, 12, 13, ...
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test27() throws Throwable {
        byte[] byteArray0 = new byte[2];
        FileHeader fileHeader0 = new FileHeader(byteArray0, 1175);
        HunkHeader.OldImage hunkHeader_OldImage0 = mock(HunkHeader.OldImage.class, new ViolatedAssumptionAnswer());
        HunkHeader hunkHeader0 = new HunkHeader(fileHeader0, 0, hunkHeader_OldImage0);
        fileHeader0.endOffset = 1175;
        hunkHeader0.getFileHeader();
        assertEquals(0, hunkHeader0.getStartOffset());
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se os
    *     valores inicializados do HunkHead são iguais aos recuperados.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test28() throws Throwable {
        byte[] byteArray0 = new byte[5];
        FileHeader fileHeader0 = new FileHeader(byteArray0, (-1759));
        Edit edit0 = new Edit(0, 1412, 0, 0);
        EditList editList0 = EditList.singleton(edit0);
        HunkHeader hunkHeader0 = new HunkHeader(fileHeader0, editList0);
        int int0 = hunkHeader0.getEndOffset();
        assertEquals(5, int0);
        assertEquals(0, hunkHeader0.getLinesContext());
        assertEquals(0, hunkHeader0.getNewLineCount());
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     o valor da variável endOffset é igual ao retornado por getEndOffset().
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test29() throws Throwable {
        byte[] byteArray0 = new byte[6];
        FileHeader fileHeader0 = new FileHeader(byteArray0, 92);
        HunkHeader hunkHeader0 = new HunkHeader(fileHeader0, 633);
        hunkHeader0.endOffset = (-25);
        int int0 = hunkHeader0.getEndOffset();
        assertEquals((-25), int0);
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste possui duplicações em relação ao 0, 4, 5, 6, 8, 10, 12, 13, ...
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test30() throws Throwable {
        FileHeader fileHeader0 = new FileHeader((byte[]) null, 3);
        HunkHeader.OldImage hunkHeader_OldImage0 = mock(HunkHeader.OldImage.class, new ViolatedAssumptionAnswer());
        HunkHeader hunkHeader0 = new HunkHeader(fileHeader0, 1445, hunkHeader_OldImage0);
        hunkHeader0.getBuffer();
        assertEquals(1445, hunkHeader0.getStartOffset());
    }


    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se os
    *     valores inicializados do HunkHead são iguais aos recuperados.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test31() throws Throwable {
        byte[] byteArray0 = new byte[1];
        FileHeader fileHeader0 = new FileHeader(byteArray0, 0);
        Edit edit0 = new Edit(3008, 91, 656, (-3099));
        EditList editList0 = EditList.singleton(edit0);
        HunkHeader hunkHeader0 = new HunkHeader(fileHeader0, editList0);
        hunkHeader0.getBuffer();
        assertEquals(1, hunkHeader0.getEndOffset());
        assertEquals((-3755), hunkHeader0.getNewLineCount());
        assertEquals(0, hunkHeader0.getLinesContext());
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste não verifica o comportamento da classe alvo.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */

    @Test(timeout = 4000)
    public void test33() throws Throwable {
        FileHeader fileHeader0 = new FileHeader((byte[]) null, 3);
        HunkHeader hunkHeader0 = new HunkHeader(fileHeader0, 717, (HunkHeader.OldImage) null);
        // Undeclared exception!
        try {
            hunkHeader0.toString();
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("org.eclipse.jgit.patch.HunkHeader", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     a função toEditList() lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test34() throws Throwable {
        HunkHeader hunkHeader0 = new HunkHeader((FileHeader) null, 1895, (HunkHeader.OldImage) null);
        // Undeclared exception!
        try {
            hunkHeader0.toEditList();
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("org.eclipse.jgit.patch.HunkHeader", e);
        }
    }


    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     a função skipLine() lança uma ArrayIndexOutOfBoundsException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test35() throws Throwable {
        FileHeader fileHeader0 = mock(FileHeader.class, new ViolatedAssumptionAnswer());
        HunkHeader hunkHeader0 = new HunkHeader(fileHeader0, 253);
        String[] stringArray0 = new String[2];
        int[] intArray0 = new int[8];
        // Undeclared exception!
        try {
            hunkHeader0.skipLine(stringArray0, intArray0, 253);
            fail("Expecting exception: ArrayIndexOutOfBoundsException");

        } catch (ArrayIndexOutOfBoundsException e) {
            //
            // 253
            //
            verifyException("org.eclipse.jgit.patch.HunkHeader", e);
        }
    }


    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     a função parseHeader() lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test36() throws Throwable {
        HunkHeader hunkHeader0 = new HunkHeader((FileHeader) null, 635);
        // Undeclared exception!
        try {
            hunkHeader0.parseHeader();
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("org.eclipse.jgit.patch.HunkHeader", e);
        }
    }


    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguinte comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     a função parseHeader() lança uma ArrayIndexOutOfBoundsException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test37() throws Throwable {
        byte[] byteArray0 = new byte[1];
        FileHeader fileHeader0 = new FileHeader(byteArray0, 0);
        HunkHeader hunkHeader0 = fileHeader0.newHunkHeader(2993);
        // Undeclared exception!
        try {
            hunkHeader0.parseHeader();
            fail("Expecting exception: ArrayIndexOutOfBoundsException");

        } catch (ArrayIndexOutOfBoundsException e) {
            //
            // 2993
            //
            verifyException("org.eclipse.jgit.patch.HunkHeader", e);
        }
    }

}
