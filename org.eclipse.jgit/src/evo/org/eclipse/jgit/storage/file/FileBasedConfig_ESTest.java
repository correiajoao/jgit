/*
* This file was automatically generated by EvoSuite
* Tue Feb 25 20:50:03 GMT 2020
*/

package org.eclipse.jgit.storage.file;

import org.eclipse.jgit.internal.storage.dfs.DfsRepositoryDescription;
import org.eclipse.jgit.internal.storage.dfs.InMemoryRepository;
import org.eclipse.jgit.lib.Config;
import org.eclipse.jgit.lib.StoredConfig;
import org.eclipse.jgit.util.*;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.mock.java.io.MockFile;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

import static org.evosuite.runtime.EvoAssertions.*;
import static org.junit.Assert.*;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true, useJEE = true)
public class FileBasedConfig_ESTest extends FileBasedConfig_ESTest_scaffolding {

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     o tamanho do conteúdo em FileBasedConfig é igual ao esperado.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test00() throws Throwable {
        Config config0 = new Config();
        MockFile mockFile0 = new MockFile("\"*]66l");
        FS_Win32 fS_Win32_0 = new FS_Win32();
        FileBasedConfig fileBasedConfig0 = new FileBasedConfig(config0, mockFile0, fS_Win32_0);
        EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("2zEzw'rNk");
        FileSystemHandling.appendLineToFile(evoSuiteFile0, "~/");
        byte[] byteArray0 = fileBasedConfig0.readIncludedConfig("2zEzw'rNk");
        assertEquals(3, byteArray0.length);
    }


    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     o conteúdo em FileBasedConfig é igual ao esperado.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test01() throws Throwable {
        Config config0 = new Config();
        MockFile mockFile0 = new MockFile("\"*]66l");
        FS_Win32 fS_Win32_0 = new FS_Win32();
        FileBasedConfig fileBasedConfig0 = new FileBasedConfig(config0, mockFile0, fS_Win32_0);
        EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("2zEzw'rNk");
        byte[] byteArray0 = new byte[0];
        FileSystemHandling.appendDataToFile(evoSuiteFile0, byteArray0);
        byte[] byteArray1 = fileBasedConfig0.readIncludedConfig("2zEzw'rNk");
        assertArrayEquals(new byte[]{}, byteArray1);
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     FileBasedConfig é igual a null.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test02() throws Throwable {
        FileBasedConfig fileBasedConfig0 = new FileBasedConfig((Config) null, (File) null, (FS) null);
        File file0 = fileBasedConfig0.getFile();
        assertNull(file0);
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     o tamanho do arquivo em FileBasedConfig é igual ao esperado.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test03() throws Throwable {
        FS_Win32_Cygwin fS_Win32_Cygwin0 = new FS_Win32_Cygwin();
        File file0 = MockFile.createTempFile("(7T^`", "(7T^`");
        FileBasedConfig fileBasedConfig0 = new FileBasedConfig(file0, fS_Win32_Cygwin0);
        EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("/var/folders/9c/2fm2fk412pj9zjkzvdx9w2fr0000gn/T/(7T^`0(7T^`");
        FileSystemHandling.appendStringToFile(evoSuiteFile0, "f3L");
        File file1 = fileBasedConfig0.getFile();
        assertEquals(3L, file1.length());
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     o arquivo em FileBasedConfig tem isHiden() igual a true.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test04() throws Throwable {
        SystemReader systemReader0 = SystemReader.getInstance();
        Config config0 = new Config();
        FS_Win32_Cygwin fS_Win32_Cygwin0 = new FS_Win32_Cygwin();
        FileBasedConfig fileBasedConfig0 = systemReader0.openUserConfig(config0, fS_Win32_Cygwin0);
        File file0 = fileBasedConfig0.getFile();
        assertTrue(file0.isHidden());
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     o arquivo em FileBasedConfig tem canWrite() igual a true.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test05() throws Throwable {
        MockFile mockFile0 = new MockFile("", "");
        FS_Win32_Cygwin fS_Win32_Cygwin0 = new FS_Win32_Cygwin();
        FileBasedConfig fileBasedConfig0 = new FileBasedConfig(mockFile0, fS_Win32_Cygwin0);
        File file0 = fileBasedConfig0.getFile();
        assertTrue(file0.canWrite());
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     o arquivo em FileBasedConfig tem tamanho igual a zero.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test06() throws Throwable {
        DfsRepositoryDescription dfsRepositoryDescription0 = new DfsRepositoryDescription();
        InMemoryRepository inMemoryRepository0 = new InMemoryRepository(dfsRepositoryDescription0);
        StoredConfig storedConfig0 = inMemoryRepository0.getConfig();
        MockFile mockFile0 = new MockFile("W*((!3RxeC]IN(-%/K+");
        FS_POSIX fS_POSIX0 = (FS_POSIX) FS.DETECTED;
        FileBasedConfig fileBasedConfig0 = new FileBasedConfig(storedConfig0, mockFile0, fS_POSIX0);
        File file0 = fileBasedConfig0.getFile();
        assertEquals(0L, file0.length());
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste não verifica o comportamento da classe alvo.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test07() throws Throwable {
        FileBasedConfig fileBasedConfig0 = new FileBasedConfig((Config) null, (File) null, (FS) null);
        // Undeclared exception!
        try {
            fileBasedConfig0.toString();
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("org.eclipse.jgit.storage.file.FileBasedConfig", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     a chamada ao método save() com parâmetros inválidos lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test08() throws Throwable {
        Config config0 = new Config();
        FileBasedConfig fileBasedConfig0 = new FileBasedConfig(config0, (File) null, (FS) null);
        // Undeclared exception!
        try {
            fileBasedConfig0.save();
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("org.eclipse.jgit.internal.storage.file.LockFile", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     a chamada ao método readIncludedConfig() com parâmetros inválidos lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test09() throws Throwable {
        Config config0 = new Config();
        MockFile mockFile0 = new MockFile(",Z9 D$:h$unXZ4(");
        FileBasedConfig fileBasedConfig0 = new FileBasedConfig(config0, mockFile0, (FS) null);
        // Undeclared exception!
        try {
            fileBasedConfig0.readIncludedConfig("7Fl<:|pLe1qa");
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("org.eclipse.jgit.storage.file.FileBasedConfig", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     a chamada ao método load() com parâmetros inválidos lança uma Exception.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test10() throws Throwable {
        FS_Win32_Cygwin fS_Win32_Cygwin0 = new FS_Win32_Cygwin();
        File file0 = MockFile.createTempFile("(7T^`", "(7T^`");
        EvoSuiteFile evoSuiteFile0 = new EvoSuiteFile("/var/folders/9c/2fm2fk412pj9zjkzvdx9w2fr0000gn/T/(7T^`0(7T^`");
        byte[] byteArray0 = new byte[9];
        FileSystemHandling.appendDataToFile(evoSuiteFile0, byteArray0);
        FileBasedConfig fileBasedConfig0 = new FileBasedConfig(file0, fS_Win32_Cygwin0);
        try {
            fileBasedConfig0.load();
            fail("Expecting exception: Exception");

        } catch (Exception e) {
            //
            // Cannot read file /var/folders/9c/2fm2fk412pj9zjkzvdx9w2fr0000gn/T/(7T^`0(7T^`
            //
            verifyException("org.eclipse.jgit.storage.file.FileBasedConfig", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     a chamada ao método load() com parâmetros inválidos lança uma Exception.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test11() throws Throwable {
        DfsRepositoryDescription dfsRepositoryDescription0 = new DfsRepositoryDescription("");
        InMemoryRepository inMemoryRepository0 = new InMemoryRepository(dfsRepositoryDescription0);
        StoredConfig storedConfig0 = inMemoryRepository0.getConfig();
        FS_Win32_Cygwin fS_Win32_Cygwin0 = new FS_Win32_Cygwin();
        FileBasedConfig fileBasedConfig0 = new FileBasedConfig(storedConfig0, (File) null, fS_Win32_Cygwin0);
        // Undeclared exception!
        try {
            fileBasedConfig0.load();
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("org.eclipse.jgit.util.FileUtils", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     a chamada ao método isOutdated() com parâmetros inválidos lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test12() throws Throwable {
        FS_Win32_Cygwin fS_Win32_Cygwin0 = new FS_Win32_Cygwin();
        FileBasedConfig fileBasedConfig0 = new FileBasedConfig((File) null, fS_Win32_Cygwin0);
        // Undeclared exception!
        try {
            fileBasedConfig0.isOutdated();
            fail("Expecting exception: NullPointerException");

        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("org.eclipse.jgit.util.FileUtils", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste não verifica o comportamento da classe alvo.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test13() throws Throwable {
        FS_Win32_Cygwin fS_Win32_Cygwin0 = new FS_Win32_Cygwin();
        File file0 = MockFile.createTempFile("(7T^`", "(7T^`");
        FileBasedConfig fileBasedConfig0 = new FileBasedConfig(file0, fS_Win32_Cygwin0);
        fileBasedConfig0.clear();
    }


    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     a chamada ao método readIncludedConfig() com parâmetros inválidos lança uma NullPointerException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test14() throws Throwable {
        Boolean boolean0 = new Boolean(false);
        FS fS0 = FS.detect(boolean0);
        FileBasedConfig fileBasedConfig0 = new FileBasedConfig((File) null, fS0);
        try {
            fileBasedConfig0.readIncludedConfig("~/");
            fail("Expecting exception: Exception");

        } catch (Exception e) {
            //
            // Cannot read file ~/
            //
            verifyException("org.eclipse.jgit.storage.file.FileBasedConfig", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     o conteúdo em FileBasedConfig sem inicialização é igual a nulo.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test15() throws Throwable {
        Config config0 = new Config();
        MockFile mockFile0 = new MockFile("\"*]66l");
        FS_Win32 fS_Win32_0 = new FS_Win32();
        FileBasedConfig fileBasedConfig0 = new FileBasedConfig(config0, mockFile0, fS_Win32_0);
        byte[] byteArray0 = fileBasedConfig0.readIncludedConfig("2zEzw'rNk");
        assertNull(byteArray0);
    }

    /*
    * Informações do teste
    *
    * Plausível: não
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     a chamada ao método createTempFile() com parâmetros inválidos lança uma SecurityException.  Apesar de funcional, o teste não parece plausível pois tem um nível de
    *     especificidade muito alto.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test16() throws Throwable {
        Future<?> future = executor.submit(new Runnable() {
            @Override
            public void run() {
                try {
                    FS_Win32_Cygwin fS_Win32_Cygwin0 = new FS_Win32_Cygwin();
                    File file0 = MockFile.createTempFile("(7T^`", "(7T^`");
                    FileBasedConfig fileBasedConfig0 = new FileBasedConfig(file0, fS_Win32_Cygwin0);
                    // Undeclared exception!
                    try {
                        fileBasedConfig0.save();
                        fail("Expecting exception: SecurityException");

                    } catch (SecurityException e) {
                        //
                        // Security manager blocks (\"java.io.FilePermission\" \"/var/folders/9c/2fm2fk412pj9zjkzvdx9w2fr0000gn/T/(7T^`0(7T^`.lock\" \"write\")
                        // java.lang.Thread.getStackTrace(Thread.java:1552)
                        // org.evosuite.runtime.sandbox.MSecurityManager.checkPermission(MSecurityManager.java:434)
                        // java.lang.SecurityManager.checkWrite(SecurityManager.java:979)
                        // sun.nio.fs.UnixChannelFactory.open(UnixChannelFactory.java:247)
                        // sun.nio.fs.UnixChannelFactory.newFileChannel(UnixChannelFactory.java:136)
                        // sun.nio.fs.UnixChannelFactory.newFileChannel(UnixChannelFactory.java:148)
                        // sun.nio.fs.UnixFileSystemProvider.newByteChannel(UnixFileSystemProvider.java:212)
                        // java.nio.file.Files.newByteChannel(Files.java:361)
                        // java.nio.file.Files.createFile(Files.java:632)
                        // org.eclipse.jgit.util.FS_POSIX.createNewFileAtomic(FS_POSIX.java:398)
                        // org.eclipse.jgit.internal.storage.file.LockFile.lock(LockFile.java:132)
                        // org.eclipse.jgit.storage.file.FileBasedConfig.save(FileBasedConfig.java:219)
                        // sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
                        // sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
                        // sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
                        // java.lang.reflect.Method.invoke(Method.java:497)
                        // org.evosuite.testcase.statements.MethodStatement$1.execute(MethodStatement.java:257)
                        // org.evosuite.testcase.statements.AbstractStatement.exceptionHandler(AbstractStatement.java:169)
                        // org.evosuite.testcase.statements.MethodStatement.execute(MethodStatement.java:220)
                        // org.evosuite.testcase.execution.TestRunnable.executeStatements(TestRunnable.java:307)
                        // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:213)
                        // org.evosuite.testcase.execution.TestRunnable.call(TestRunnable.java:55)
                        // java.util.concurrent.FutureTask.run(FutureTask.java:266)
                        // java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
                        // java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
                        // java.lang.Thread.run(Thread.java:745)
                        //
                        verifyException("org.evosuite.runtime.sandbox.MSecurityManager", e);
                    }
                } catch (Throwable t) {
                    // Need to catch declared exceptions
                }
            }
        });
        future.get(4000, TimeUnit.MILLISECONDS);
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     a chamada ao método load() com parâmetros inválidos lança uma IOException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test17() throws Throwable {
        FS_Win32_Cygwin fS_Win32_Cygwin0 = new FS_Win32_Cygwin();
        File file0 = MockFile.createTempFile("(7T^`", "(7T^`");
        FileBasedConfig fileBasedConfig0 = new FileBasedConfig(file0, fS_Win32_Cygwin0);
        FileSystemHandling.shouldAllThrowIOExceptions();
        try {
            fileBasedConfig0.load();
            fail("Expecting exception: IOException");

        } catch (IOException e) {
            //
            // Cannot read file /var/folders/9c/2fm2fk412pj9zjkzvdx9w2fr0000gn/T/(7T^`0(7T^`
            //
            verifyException("org.eclipse.jgit.storage.file.FileBasedConfig", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     a chamada ao método load() com parâmetros inválidos lança uma FileNotFoundException.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test18() throws Throwable {
        MockFile mockFile0 = new MockFile((File) null, "MERGING");
        FS_Win32 fS_Win32_0 = new FS_Win32();
        mockFile0.mkdirs();
        FileBasedConfig fileBasedConfig0 = new FileBasedConfig(mockFile0, fS_Win32_0);
        try {
            fileBasedConfig0.load();
            fail("Expecting exception: FileNotFoundException");

        } catch (FileNotFoundException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("org.evosuite.runtime.mock.java.io.MockFileInputStream", e);
        }
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O único comportamento verificado no teste é se ele pode ser executado no tempo de 4s. Dado que métodos para
    *     carregar dados são chamados, o teste se demonstra viável.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test19() throws Throwable {
        FS_Win32_Cygwin fS_Win32_Cygwin0 = new FS_Win32_Cygwin();
        File file0 = MockFile.createTempFile("(7T^`", "(7T^`");
        FileBasedConfig fileBasedConfig0 = new FileBasedConfig(file0, fS_Win32_Cygwin0);
        fileBasedConfig0.load();
        file0.setLastModified(0L);
        fileBasedConfig0.load();
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     em FileBasedConfig inicialisado sOutdated() é igual a true.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test20() throws Throwable {
        Config config0 = new Config();
        MockFile mockFile0 = new MockFile("\"*]66l");
        FS_Win32 fS_Win32_0 = new FS_Win32();
        FileBasedConfig fileBasedConfig0 = new FileBasedConfig(config0, mockFile0, fS_Win32_0);
        boolean boolean0 = fileBasedConfig0.isOutdated();
        assertTrue(boolean0);
    }


    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O único comportamento verificado no teste é se ele pode ser executado no tempo de 4s. Dado que métodos para
    *     carregar dados são chamados, o teste se demonstra viável.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */


    @Test(timeout = 4000)
    public void test21() throws Throwable {
        FS_Win32_Cygwin fS_Win32_Cygwin0 = new FS_Win32_Cygwin();
        File file0 = MockFile.createTempFile("(7T^`", "(7T^`");
        FileBasedConfig fileBasedConfig0 = new FileBasedConfig(file0, fS_Win32_Cygwin0);
        fileBasedConfig0.load();
        fileBasedConfig0.load();
    }

    /*
    * Informações do teste
    *
    * Plausível: sim
    *     - O teste verifica os seguintes comportamentos: primeiro se ele pode ser executado no tempo de 4s; Em seguida, se
    *     em FileBasedConfig inicialisado sOutdated() é igual a false.
    *
    * Compreensivel: sim
    *     - O comportamento do teste e suas instruções são compreesíveis.
    */
    @Test(timeout = 4000)
    public void test22() throws Throwable {
        Config config0 = new Config();
        MockFile mockFile0 = new MockFile("\"*]66l");
        FS_Win32 fS_Win32_0 = new FS_Win32();
        FileBasedConfig fileBasedConfig0 = new FileBasedConfig(config0, mockFile0, fS_Win32_0);
        fileBasedConfig0.load();
        boolean boolean0 = fileBasedConfig0.isOutdated();
        assertFalse(boolean0);
    }


}
